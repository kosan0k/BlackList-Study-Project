# Принципы SOLID

## SRP - Single Responsobility Principle (Принцип единственной ответственности)

**_Модуль должен иметь только одну причину для изменения_** или **_Модуль должен отвечать за одного и только одного актора_** (где актор - связанная группа объектов, желающих изменения модуля; модуль - файл с исходным кодом)) - так трактует этот принцип **Робер Мартин** в своей книге *Совершенный код*.

По словам автора (*Роберт Мартин* первым назвал эпринципы **SOLID**) данный принцип применим только для классов.
На уровне компонентов(сборок) он превращается в принцип согласованного изменения (*Common Closure Principle; CPP*). 

Например:
```csharp
namespace BlackList.Domain.Models
{
    public class Person
    {  
        public FullName FullName { get; set; } 

        public string Position { get; set; } //должность

        public string Notes { get; set; } //заметки

        public DateTime DateOfBirth { get; set; }
    }
}
```
Класс соблюдает принцип, так как имеет только **одну причину для изменений**: изменение или расширение необходимой информации о человеке.
Класс соблюдает принцип, так как **актором**, использующим этот класс, могут быть любые объекты, которым необходима вся информация об этой сущности для визуализации (предствления, модели представления) или хранения (сущность в *Entity Framework*). Таким образом **класс Person отвечает только за одного актора**. 

Так же **класс Person имеет только одну причину для изменений**: изменение или расширение *всей доступной* информации о человеке, необходимой для представления или хранения.

Если же класс **Person** будет содержать в том числе методы типа 
```csharp
namespace BlackList.Domain.Models
{
    public class Person
    {  
        public FullName FullName { get; set; } 

       ...
       
       public double CalculatePersonPay() //подсчет доходов
       {
           ...
       }
    }
}
```
то, измененный класс будет нарушать принцип, так как **появляется дополнительная причина для изменений** - изменения указанного метода будет определяться логикой  бизнесс-модели бухгалтерии(или схожей), которым необходим только этот метод, без остальных свойств.

Так же эта бизнесс-модель бухгалтерии не может быть частью **актора**, определенного выше, так как она не использует информацию о человеке, а только один метод. Таким образом, **класс Person теперь отвечает за двоих акторов**, ведь предыдущим актором (представления, модели представления и т.д.) добавленный метод не используется.

## OCP - The Open Closed Principle (Принцип открытости\закрытости)

Сформулирован Бертраном Мейером в 1988 году. Он гласит: **Программные сущности должны быть открыты для расширения и закрыты для изменения**.

Под программными сущностями понимаются сужности любого уровня (класс, сборка, или даже пространство имен). 

Возьмем указанный ранее пример класса
```csharp
namespace BlackList.Domain.Models
{
    public class Person
    {  
        public FullName FullName { get; set; } 

        public string Position { get; set; } //должность

        public string Notes { get; set; } //заметки

        public DateTime DateOfBirth { get; set; }
    }
}
```

Для соблюдения принципа мы не можем **изменять** какое-либо из уже определенных свойств, т.к. на них может быть завязана логика работы других классов. Однако мы можем **добавлять** новые свойства, т.к. это никак не изменит имеющийся.

## LSP - The Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

Оригинальное определение Барбары Лисков: 

*Если для каждого объекта **о1** типа **S** существует такой объект **о2** типа **T**, что для всех программ **P**, определенных в терминах **T**, поведение **P** не изменяется при подстановке **o1** вместо **о2**, то **S** является подтипом **T***.

Иными словами: *Поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода, использующего переменную базового типа.*

В нашем проекте есть класс **ViewModelBase**
```csharp
namespace BlackList.Ui.Wpf.Host.ViewModels
{
    public class BaseViewModel : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        public void OnPropertyChanged([CallerMemberName] string caller = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(caller));
        }

        public void OnPropertyChanged(object sender, [CallerMemberName] string caller = null)
        {
            PropertyChanged?.Invoke(sender, new PropertyChangedEventArgs(caller));
        }

    }
}
```

Он наследуется от интерфейса [**INotifyPropertyChanged**](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=net-5.0), который необходим для уведомления клиента(в нашем случае - представления) о том, что свойство изменилось. 

Таким образом, клиент(представление) от наследников **ViewModelBase** ожидает применение какой-либо из перегрузок метода *OnPropertyChanged(...)* для информирования об обновлении свойств и только.  **Ни в коем случае нельзя изменять это поведение в классах-наследниках**. 

## ISP - The Interface Segregation Principle (Принцип разделения интерфейсов)

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе.

Под интерфейсом здесь понимается именно Java, C# интерфейс. Разделение интерфейса облегчает использование и тестирование модулей. 

Рассмотрим интерфейс:
```csharp
namespace BlackList.Storage
{
    public interface IStorage
    {
        Task<IEnumerable<Person>> GetAllPersonsAsync();

        Task<IAsyncEnumerable<Person>> FindPersonAsync(string name);

        Task<bool> TrySavePersonAsync(Person person);

        Task<bool> TryDeletePersonAsync(Person person);

        Task<bool> TryUpdatePersonAsync(Person unchangedPerson, Person modifiedPerson);
    }
}
```

В данном интерфейсе определена только логика **CRUD** сущности *Person*. 

## DIP - The Dependency Inversion Principle (Инверсия зависимостей)

Формулировка:

* Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Чем ближе модуль к вводу/выводу, тем ниже уровень модуля. Т.е. модули, работающие с базой данных, интерфейсом пользователя, низкого уровня. А модули, реализующие бизнес-логику — высокого уровня.

В модулях высокого уровня, мы должны использовать интерфейсы, а не конктретные реализации. 

Например, использовать приведенный выше интерфейс **IStorage** вместо реализации(**SqlStorage**(пространство имен (*BlackList.Storage.Sql*))). 

```csharp
public class MainViewModel : BaseViewModel
    {
       ...
        private static IStorage _storage;
        public MainViewModel(IStorage storage)
        {
            _storage = storage ?? throw new ArgumentNullException(nameof(storage));
            ...     
        }
        ...
        private async Task DeleteSelectedPersonAsync() 
        {
            var deletionSucceed = await _storage.TryDeletePersonAsync(_selectedPerson);
            ...
        }
    }
```
В данном случае модель представления использует интерфейс, для определения параметра контруктора и приватного поля. И мы можем передать в контруктор любую реализацию интерфейса **IStorage**. Таким образом **MainViewModel** не зависит от способа хранения данных. Она вообще не должна знать и вникать, каким образом устроено хранение данных. 
